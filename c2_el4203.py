# -*- coding: utf-8 -*-
"""C2_EL4203

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nhC6vxXeZoEpiK8UawfWPmaD-E4Y0gj-
"""

pip install python-docx

import os
from docx import Document

import os

def read_text(file_path):
    """
    Reads the content from a text file or document.

    Args:
    - file_path (str): Path to the file to read

    Returns:
    - str: Content of the file

    Raises:
    - ValueError: If the file format is not supported
    """
    extension = file_path.split('.')[-1].lower()
    if extension == 'txt':
        with open(file_path, 'r') as file:
            return file.read()
    elif extension == 'doc':
        doc = Document(file_path)
        return '\n'.join([para.text for para in doc.paragraphs])
    else:
        raise ValueError("Unsupported file format")

def write_file(path_file, content):
    """
    Writes content to a file.

    Args:
    - path_file (str): Path to the file to write
    - content (str): Content to write to the file
    """
    with open(path_file, 'w') as file:
        file.write(content)

def delete_file(path_file):
    """
    Deletes a file.

    Args:
    - path_file (str): Path to the file to delete
    """
    os.remove(path_file)

def create_file(path_file):
    """
    Creates a new file.

    Args:
    - path_file (str): Path to the file to create
    """
    with open(path_file, 'w'):
        pass

def common_substring_search(str1, str2):
    """
    Finds the longest common substring between two strings.

    Args:
    - str1 (str): First string
    - str2 (str): Second string

    Returns:
    - str: Longest common substring
    """
    n = len(str1)
    m = len(str2)
    result = 0
    end = 0

    length = [[0] * (m + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if str1[i - 1] == str2[j - 1]:
                length[i][j] = length[i - 1][j - 1] + 1
                if length[i][j] > result:
                    result = length[i][j]
                    end = i - 1

    return str1[end - result + 1:end + 1]

def word_break(s, word_dict):
    """
    Determines if a string can be segmented into valid words using a given dictionary.

    Args:
    - s (str): Input string to be segmented
    - word_dict (set): Set of valid words

    Returns:
    - bool: True if the string can be segmented into valid words, False otherwise
    """
    dp = [False] * (len(s) + 1)
    dp[0] = True

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_dict:
                dp[i] = True
                break
            # Check if substring has a common substring with a suffix
            elif common_substring_search(s[j:i], s[i:]):
                dp[i] = True
                break

    return dp[-1]


def word_wrap_dp(text, max_length):
    """
    Wraps text into lines of a specified maximum length using dynamic programming,
    with adjustments based on common substrings between words.

    Args:
    - text (str): Input text to be wrapped
    - max_length (int): Maximum length of each line

    Returns:
    - list of str: Wrapped text lines
    """
    words = text.split()
    n = len(words)
    dp = [float('inf')] * (n + 1)
    dp[0] = 0
    result = [-1] * (n + 1)

    for i in range(1, n + 1):
        length = -1
        for j in range(i, 0, -1):
            length += len(words[j - 1]) + 1
            if length > max_length:
                break
            if dp[j - 1] + (max_length - length + 1) ** 2 < dp[i]:
                dp[i] = dp[j - 1] + (max_length - length + 1) ** 2
                result[i] = j - 1

    lines = []
    i = n
    while i > 0:
        j = result[i]
        lines.append(' '.join(words[j:i]))
        i = j

    lines.reverse()
    return lines

def format_text(text, max_length):
    """
    Formats text into justified lines of a specified maximum length.

    Args:
    - text (str): Input text to be formatted
    - max_length (int): Maximum length of each line

    Returns:
    - list of str: Justified text lines
    """
    words = text.split()

    # Check if the text can be segmented into valid words
    word_dict = set(words)  # Assume all words in text are valid
    if not word_break(text.replace(" ", ""), word_dict):
        return ["Text cannot be segmented into valid words with the provided dictionary."]

    # Perform word wrapping and formatting
    formatted_lines = word_wrap_dp(text, max_length)

    # Justify each line
    justified_lines = []
    for line in formatted_lines:
        words_in_line = line.split()
        if len(words_in_line) == 1:
            justified_lines.append(words_in_line[0].ljust(max_length))
        else:
            total_spaces_needed = max_length - sum(len(word) for word in words_in_line)
            if len(words_in_line) > 1:
                min_spaces_between_words = total_spaces_needed // (len(words_in_line) - 1)
                extra_spaces = total_spaces_needed % (len(words_in_line) - 1)

                justified_line = words_in_line[0]
                for i in range(1, len(words_in_line)):
                    spaces_to_add = min_spaces_between_words + (1 if i <= extra_spaces else 0)
                    justified_line += ' ' * spaces_to_add + words_in_line[i]

                justified_lines.append(justified_line)

    return justified_lines

# Example usage
text = "This is a programming problem which demonstrates dynamic programming"
max_length = 15

formatted_text = format_text(text, max_length)
for line in formatted_text:
    print(f"'{line}'")

# Ejemplo con un archivo de texto genÃ©rico
text = read_text("text.txt")
maxWidth = 15
print(format_text(text, maxWidth))