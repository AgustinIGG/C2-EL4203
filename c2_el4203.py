# -*- coding: utf-8 -*-
"""C2_EL4203

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nhC6vxXeZoEpiK8UawfWPmaD-E4Y0gj-
"""

pip install python-docx

import os
from docx import Document

TXT_FILE = "txt"
DOCX_FILE = "docx"

def get_file_extension(ruta_archivo):
    """
    Obtiene la extensión de un archivo a partir de su ruta.

    Args:
    - file_path (str): Ruta del archivo del cual se desea obtener la extensión.

    Returns:
    - str: Extensión del archivo en minúsculas.
    """
    return ruta_archivo.split('.')[-1].lower()

def create_file(ruta_archivo, contenido):
    """
    Crea un nuevo archivo en la ruta especificada y escribe el contenido proporcionado.

    Args:
    - ruta_archivo (str): Ruta del archivo a crear.
    - contenido (str): Contenido que se escribirá en el archivo.

    Returns:
    - None
    """
    with open(ruta_archivo, 'w') as file:
        file.write(contenido)


def read_file(ruta_archivo):
    """
     lee el contenido de un archivo 'ruta_archivo'

     Args:
     - ruta_archivo (str): ruta del archivo a leer

     Retorna:
     - str: contenido el archivo como un string

     Raises:
     - FileNotFoundError: si el archivo 'ruta_archivo' no existe
     """
    if not os.path.exists(ruta_archivo):
        raise FileNotFoundError(f"File '{ruta_archivo}' not found.")

    file_extension = get_file_extension(ruta_archivo)
    if file_extension == TXT_FILE:
        with open(ruta_archivo, 'r') as file:
            return file.read()
    elif file_extension == DOCX_FILE:
        doc = Document(ruta_archivo)
        return "\n".join([para.text for para in doc.paragraphs])
    else:
        raise ValueError("Unsupported file format")

def update_file(ruta_archivo, new_contenido):
    """
    actualiza el contenido de un archivo existente en la ruta especificada

    Args:
    - ruta_archivo (str): ruta del archivo a actualizar
    - new_contenido (str): nuevo contenido que se escribirá en el archivo

    Returns:
    - None
    """
    with open(ruta_archivo, 'w') as file:
        file.write(new_contenido)

def delete_file(ruta_archivo):
    """
    elimina un archivo especificado por la ruta del archivo

    Args:
    - ruta_archivo (str): ruta del archivo a eliminar

    Returns:
    - None
    """
    os.remove(ruta_archivo)

def longest_common_substring(X, Y):
    """
    Encuentra el substring común más largo entre los strings X e Y

    Args:
    - X (str): Primer string
    - Y (str): Segundo string

    Retorna:
    - str: substring común mas largo encontrado
    """
    m = len(X)
    n = len(Y)
    dp = [[0] * (n + 1) for _ in range(2)]
    length = 0
    end_index = 0
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                dp[1][j] = dp[0][j - 1] + 1
                if dp[1][j] > length:
                    length = dp[1][j]
                    end_index = i
            else:
                dp[1][j] = 0
        dp[0] = dp[1][:]
    start_index = end_index - length
    longest_substring = X[start_index:end_index]
    return f'The longest common substring is "{longest_substring}" and is of length {length}.'

def word_break(s, word_dict):
    """
    Checkea si 's' puede ser segmentado en palabras del diccionario 'word_dict'

    Args:
    - s (str): Input string a ser segmentado
    - word_dict (dict): conjuntos de palabras en el diccionario

    Retorna:
    - bool: True si 's' puede ser segmentado en palabras de 'word_dict', falso sino
    """
    dp = [False] * (len(s) + 1)
    dp[0] = True
    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in word_dict:
                dp[i] = True
                break
    return dp[-1]

def word_wrap(words, maxWidth):
    """
    Implementa al algoritno word_wrap utilizando programación dinámica

    Args:
    - words (list): lista de palabras para ser ajustadas
    - maxWidth (int): ancho máximo permitido para cada línea

    Returns:
    - list: índices de palabras donde se deben realizar los saltos de línea optimizados
    """
    n = len(words)
    cost = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        cost[i][i] = maxWidth - len(words[i])
        for j in range(i + 1, n):
            cost[i][j] = cost[i][j - 1] - len(words[j]) - 1
    for i in range(n):
        for j in range(i, n):
            if cost[i][j] < 0:
                cost[i][j] = float('inf')
            else:
                cost[i][j] = cost[i][j] ** 2
    min_cost = [0] * n
    result = [0] * n
    for i in range(n - 1, -1, -1):
        min_cost[i] = cost[i][n - 1]
        result[i] = n
        for j in range(n - 1, i, -1):
            if cost[i][j - 1] == float('inf'):
                continue
            if min_cost[i] > min_cost[j] + cost[i][j - 1]:
                min_cost[i] = min_cost[j] + cost[i][j - 1]
                result[i] = j
    return result

def format_text(text: str, maxWidth: int):
    """
    Formatea el texto para que cada línea tenga como máximo 'maxWidth' caracteres

    Args:
    -text (str): texto a formatear
    - maxWidth (int): ancho máximo permitido para cada línea

    Returns:
    -list : lista para líneas formateadas
    """
    words = text.split()
    line_breaks = word_wrap(words, maxWidth)
    lines = []
    i = 0
    while i < len(words):
        current_line = words[i:line_breaks[i]]
        lines.append(current_line)
        i = line_breaks[i]
    """
    Justifica una línea de texto para que tenga un ancho máximo `maxWidth`.

    Args:
    - line (list): Lista de palabras que forman la línea.

    Returns:
    - str: Línea justificada con espacios adicionales distribuidos uniformemente entre las palabras.
    """
    def justify_line(line):
        if len(line) == 1:
            return line[0].ljust(maxWidth)
        total_spaces = maxWidth - sum(len(word) for word in line)
        spaces = [' '] * (len(line) - 1)
        for i in range(total_spaces):
            spaces[i % len(spaces)] += ' '
        return ''.join(word + space for word, space in zip(line, spaces + ['']))
    result = [justify_line(line) for line in lines[:-1]]
    last_line = ' '.join(lines[-1]).ljust(maxWidth)
    result.append(last_line)
    return result


def process_file(ruta_archivo):
    """
    Procesa un archivo especificado por 'ruta_archivo', realizando las operaciones requeridas

    Args:
    - ruta_archivo (str): ruta del archivo a procesar
    """
    contenido = read_file(ruta_archivo)

    # Longest Common Substring  (asumiendo que necesitamos comparar dos partes del mismo texto, por ejemplo)
    lcs_result = longest_common_substring(contenido[:len(contenido)//2], contenido[len(contenido)//2:])
    print(lcs_result)

    # Word Break (asumiendo que se proporciona un diccionario de muestra)
    word_dict = {"this", "is", "a", "sample", "dictionary", "dynamic", "programming"}
    wb_result = word_break(contenido, word_dict)
    print(f'Can the content be segmented into words from the dictionary? {wb_result}')

    # Word Wrap (asumiendo que se proporciona un maxWidth)
    maxWidth = 30
    wrapped_text = format_text(contenido, maxWidth)
    print("Formatted Text:")
    for line in wrapped_text:
        print(f'"{line}"')

# Ejemplo con un archivo de texto genérico
ruta_archivo = "text.txt"
process_file(ruta_archivo)